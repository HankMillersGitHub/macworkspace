# 第一章 数据结构

## 1.1 数据结构的研究对象

### 1. 数据之间的逻辑关系

* <span style="color:orange">集合结构</span>：数据结构中的元素之间除了“同属一个集合”的相互关系外，别无其他关系，集合元素之间没有其他关系
* <span style="color:orange">线性结构</span>：元素之间存在“一对一的”对应关系，比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、队列、栈
* <span style="color:orange">树形结构</span>：元素存在“一对多的”对应关系，比如：家谱、文件系统、组织结构
* <span style="color:orange">图形结构</span>：元素存在“多对多的”对应关系，比如：地铁网

### 2. 数据的存储结构(或物理结构)

1. <span style="color:orange">顺序结构：</span>
   * 顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素
   * 优点：只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问
   * 缺点：必须静态分配连续空间，内存空间的利用率比较低，插入或删除可能需要移动大量元素，效率比较低
2. <span style="color:orange">链式结构：</span>
   * 不需要使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点，节点中除了存放数据本身以外，还需要存放指向下一个节点的指针
   * 优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点，插入或删除元素时，不需要移动大量的元素
   * 缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问
3. <span style="color:orange">索引结构：</span>
   * 除建立存储节点信息外，还建立附加的索引表来记录每个元素节点的地址，索引表由若干索引项组成。索引项的一般形式是：(关键字、地址)
   * 优点：用节点的索引号来确定节点存储地址，检索速度快
   * 缺点：增加了附加的索引表，会占用较多的存储空间，在增加和删除数据时要修改索引表，因而会花费较多的时间
4. <span style="color:orange">散列结构：</span>
   * 根据元素的关键字直接计算出该元素的存储地址，又称为hash存储
   * 优点：检索、增加和删除节点的操作都很快
   * 缺点：不支持排序，一般用线性表存储需要更多的空间，并且记录的关键字不能重复

开发中，更习惯以如下方式理解存储结构：

* 线性表(一对一)：一维数组、单向链表、双向链表、栈结构、队列
* 树(一对多)：二叉树、B+树
* 图(多对多)：
* 哈希表：HashMap、HashSet

### 3. 运算结构

施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能：运算的实现是针对存储结构的，指出运算的具体操作步骤

* 分配资源，建立结构，释放资源
* 插入和删除
* 获取和遍历
* 修改和排序

## 1.2 链表

链表中的基本单位是：节点(Node)

### 1. 单向链表

```java
// 单向链表之基础结构
class Node{
  private Object data;
  private Node next;
  public Node(Object data){
    this.data = data;
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
node1.next = node2;
```

### 2. 双向链表

```java
// 双向链表之基础结构
class Node{
  private Object data;
  private Node prev;
  private Node next;
  public Node(Object data){
    this.data = data;
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
Node node3 = new Node("CC");
node1.prev = null;
node1.next = node2;
node2.prev = node1;
node2.next = node3;
node3.prev = node2;
node3.next = null;
```

### 3. 二叉树

```java
// 二叉树之基本结构
class Node{
  private Object data;
  private Node lLeaf;
  private Node rLeaf;
  public Node(Object data){
    this.data = data;
  }
}
Node root = new Node("root");
Node lLeaf = new Node("lLeaf");
Node rLeaf = new Node("rLeaf");
root.lLeaf = lLeaf;
root.rLeaf = rLeaf;
lLeaf.lLeaf = null;
lLeaf.rLeaf = null;
rLeaf.lLeaf = null;
rLeaf.rLeaf = null;
```

### 4. 栈(Stack)

```java
// 链表实现的栈
class Node{
  Object data;
  Node next;
  public Node(Object data){
    this.data = data;
  }
}
class Stack{
  Node top;
  public Stack(Node top){
    this.top = top;
  }
  // 压栈操作
  public static push(Node node){
    if(top != null){
      top = node;
    }
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
node1.next = node2;
Stack stack = new Stack(node1);
Stack.push(node2);
```

### 5. 队列(queue)

```java
// 数组实现队列
class Queue{
  Object[] values;
  int size;
  public Queue(int length){
    values = new Object[length];
  }
  // 入队
  public void add(Object ele){
    if(size >= values.length){
      throw new RuntimeException("队列已满，入队失败");
    }
    values[size] = ele;
    size++;
  }
  // 出队
  public Object remove(){
    if(size <= 0){
      throw new RuntimeException("队列已空，出队失败");
    }
    // 取队首元素
    Object obj = values[0];
    // 循环向前
    for(int i = 1;i < size;i++){
      values[i - 1] = values[i];
    }
    // 最后的元素致空
    values[size - 1] = null;
    size--;
    return obj;
  }
}
```

## 1.3 List

### 1. ArrayList

1. 特点：

   > 实现了List接口，存储有序的、可以重复的数据
   >
   > 底层使用Object[]数组存储
   >
   > 线程不安全

2. ArrayList源码解析：

   1. JDK7

      ```java
      // 底层初始化数组，默认长度为十 Object[] elementData = new Object[10];
      ArrayList<String> list = new ArrayList<>();
      // elementData[0] = "AA"
      list.add("AA");
      // elementData[1] = "BB"
      list.add("BB");
      // 。。。
      // 当要添加第十一个元素的时候，底层elementData数组长度扩容，默认扩容为原来长度的1.5倍并将原有数组中的元素赋值到新数组中
      ```
   
   2. JDK8
   
      ```java
      // 底层初始化数组 Object[] elementData = new Object[]{};
      ArrayList<String> list = new ArrayList<>();
      // 首次添加元素时，会初始化数组elementData = new Object[10] elementData[0] = "AA"
      list.add("AA");
      // elementData[1] = "BB"
      list.add("BB");
      // 。。。
      // 当要添加第十一个元素的时候，底层elementData数组长度扩容，默认扩容为原来长度的1.5倍并将原有数组中的元素赋值到新数组中
      ```
      

### 2. LinkedArrayList

1. LinkedList的特点

   > 实现了List接口，存储有序的、可以重复的数据
   >
   > 底层使用双向链表存储
   >
   > 线程不安全的

2. LinkedList在JDK8中的源码解析

   ```java
   LinkedList<String> list = new LinkedList<>();
   // 将AA封装到Node对象中，list对象的属性first(头节点)和last(尾节点)都指向此Node对象
   list.add("AA"); 
   // 将BB封装到Node对象中，两个Node对象构成一个双向链表，头节点还指向Node1，尾节点指向Node2
   list.add("BB");
   // 因为LinkedList使用的是双向链表，不需要考虑扩容问题
   
   /*
   LinkedList内部声明
   class Node<E>{
   	E item;
   	Node<E> next;
   	Node<E> prve;
   }
   */
   ```

### 3. 启示与开发建议

1. ArrayList底层使用数组结构，查找和添加(尾部添加)效率高，时间复杂度为O(1)；对于删除和插入操作效率低，时间复杂度为O(n)
2. LinkedList底层使用双向链表，删除和插入操作效率高，时间复杂度为O(1)，查找和添加效率低，时间复杂度为O(n),(有可能添加操作时间复杂度为O(1));
3. 在选择了ArrayList的前提下有两种创建数组的方式可选
   1. new ArrayList()：底层创建长度为10的数组
   2. new ArrayList(int copicity)：底层创建长度为copicity长度的数组
   3. 如果开发中大体确认数组长度，推荐使用new ArrayList(int copicity)构造器



## 1.4 HashMap

### 1. HashMap中元素的特点

> HashMap中的所有的key彼此之间是不可重复的、无序的，所有的key之间构成一个Set集合
>
> HashMap中的所有的value彼此之间是可重复的、无序的，所有的value构成一个Collection集合
>
> HashMap中的一组key-value，就构成了一个entry
>
> HashMap中的所有的entry彼此之间构成了一个不可重复的、无序的Set集合

### 2. HashMap源码解析

1. JDK7中创建对象和添加数据的过程

   ```java
   // 创建对象的过程中，底层会初始化数组Entry[] table = new Entry[16];
   HashMap<String,Integer> map = new HashMap<>();
   // 将("AA",80)封装为一个Entry对象中，考虑将此对象添加到table对象中
   map.put("AA",80);
   
   // 添加 / 修改 的过程
   /*
   将key1value1添加到当前的map中
   首先，需要调用key1所在的类的hashCode方法，计算key1的哈希值1，此哈希值1经过某种算法(hash(key))后得到哈希值2
   哈希值2在经过某种算法(indexFor())之后确定了Entry在table中的索引位置1
   1.1 如果此索引位置上没有元素，则entry1就添加成功			--> 情况一
   1.2 如果此索引位置上有元素(key2,value2)，则需要继续比较key1和key2的哈希值2 ---> 哈希冲突
    	2.1 如果key1的哈希值2与key2的哈希值2不同，则(key1,value1)也添加成功		--> 情况二
    	2.2 如果key1的哈希值2与key2的哈希值2相同，则需要继续比较key1和key2的equals().要调用key1所在类的equals(key2)方法，将key2作为参数传递进去
    		3.1 调用equals之后返回false：则entry1就添加成功		--> 情况三
    		3.2 调用equals之后返回true：则认为key1和key2相同，默认情况下，value1替换value2.
   
   情况一：将(key1，value1)存放到数组的索引i的位置
   情况二，情况三：(key1，value1)元素与现有的(key2，value2)构成单向链表结构，(key1，value1)指向(key2，value2)
   
   随着不断添加元素，在满足如下条件的情况下，会考虑扩容：
   (size >= threshold) && (null != table[i])
   当元素的个数达到临界值(-> 数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 = 16 * 0.75 --> 12
   默认扩容为原来的二倍
   */
   ```

2. JDK8与JDK7的不同之处

   #### JDK7

   1. 实例化的过程

      ```java
      HashMap<String,Integer> map = new HashMap<>();
      ```

      对应的源码

      ```java
      public HashMap() {
          this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
      }
      public HashMap(int initialCapacity, float loadFactor) {
          //...略...
      
          //通过此循环，得到capacity的最终值，此最终值决定了Entry数组的长度。此时的capacity一定是2的整数倍
          int capacity = 1;
          while (capacity < initialCapacity)
              capacity <<= 1;
      
          this.loadFactor = loadFactor; //确定了加载因子的值
          threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);  //确定了临界值
          table = new Entry[capacity]; //初始化数组，长度为capacity
          
          //..略..
      }
      ```

      其中：

      ```java
      static final int DEFAULT_INITIAL_CAPACITY = 16;
      static final float DEFAULT_LOAD_FACTOR = 0.75f;
      
      final float loadFactor; //加载因子
      int threshold;//临界值
      transient Entry<K,V>[] table; //存储数组的数组
      ```

   2. put(key,value)的过程

      ```java
      public V put(K key, V value) {
          //HashMap允许添加key为null的值。将此(key,value)存放到table索引0的位置。
          if (key == null)
              return putForNullKey(value);
          //将key传入hash()，内部使用了key的哈希值1，此方法执行结束后，返回哈希值2
          int hash = hash(key);
          //确定当前key，value在数组中的存放位置i
          int i = indexFor(hash, table.length);
          
          for (Entry<K,V> e = table[i]; e != null; e = e.next) {
              Object k;
              if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                  V oldValue = e.value;
                  e.value = value;
                  e.recordAccess(this);
                  return oldValue;  //如果put是修改操作，会返回原有旧的value值。
              }
          }
      
          //.....
          addEntry(hash, key, value, i); //将key,value封装为一个Entry对象，并将此对象保存在索引i位置。
          return null; //如果put是添加操作，会返回null.
      }
      ```

      其中：

      ```java
      final int hash(Object k) {
          int h = 0;
          if (useAltHashing) {
              if (k instanceof String) {
                  return sun.misc.Hashing.stringHash32((String) k);
              }
              h = hashSeed;
          }
      
          h ^= k.hashCode();
      
          // This function ensures that hashCodes that differ only by
          // constant multiples at each bit position have a bounded
          // number of collisions (approximately 8 at default load factor).
          h ^= (h >>> 20) ^ (h >>> 12);
          return h ^ (h >>> 7) ^ (h >>> 4);
      }
      
      static int indexFor(int h, int length) {
          return h & (length-1);
      }
      
      void addEntry(int hash, K key, V value, int bucketIndex) {
          //扩容的条件
          if ((size >= threshold) && (null != table[bucketIndex])) {
              resize(2 * table.length); //默认扩容为原有容量的2倍
              hash = (null != key) ? hash(key) : 0;
              bucketIndex = indexFor(hash, table.length);
          }
      
          createEntry(hash, key, value, bucketIndex);
      }
      
      void createEntry(int hash, K key, V value, int bucketIndex) {
          Entry<K,V> e = table[bucketIndex];
          table[bucketIndex] = new Entry<>(hash, key, value, e);
          size++;
      }
      ```

   3. Entry的定义如下：

      ```java
      static class Entry<K,V> implements Map.Entry<K,V> {
          final K key;
          V value;
          Entry<K,V> next;
          int hash;  //使用key得到的哈希值2进行赋值。
      
          /**
               * Creates new entry.
               */
          Entry(int h, K k, V v, Entry<K,V> n) {
              value = v;
              next = n;
              key = k;
              hash = h;
          }
      }
      ```

   #### JDK8

   > 二者不同之处：
   >
   > 1. JDK8中，当我们创建HashMap实例以后，底层并没有初始化table数组，当首次添加(key,value)时，进行判断，如果发现当前table尚未初始化，则对数组进行初始化。
   >
   > 2. JDK8中，HashMap底层定义了Node内部类，替换JDK7中的Entry。意味着我们创建的数组是Node[]
   >
   > 3. JDk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中，如果此时角标i位置上有元素，JDK7中是将新的(key,value)元素指向已有的旧的元素(头插法)，JDK8中是将旧的元素指向新的(key,value)元素(尾插法)。(七上八下)
   >
   > 4. JDK7：数组+链表。JDK8：数组+单向链表+红黑树。
   >
   >    <span style="color:orange">什么时候会使用红黑树？</span>如果数组索引i位置上的元素个数达到8，并且数组的长度达到64，我们就将此索引位置i上的多个元素，改为使用红黑树的结构进行存储。(红黑树进行put/get/remove操作时的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)要好，性能更高)。
   >
   >    <span style="color:orange">什么时候会将红黑树变为单向链表？</span>当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树的结构退化为单向链表，

3. 属性 / 字段

```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;     // 默认初始容量16
static final int MAXIMUM_CAPACITY = 1 << 30;            // 最大容量 1 << 30
static final float DEFAULT_LOAD_FACTOR = 0.75f;         // 默认加载因子
static final int TREEIFY_THRESHOLD = 8;                 // 默认树化阈值8，当链表长度达到这个长度之后，就要考虑树化
static final int UNTREEIFY_THRESHOLD = 6;               // 默认反树化阈值6，当树中的某个节点达到此阈值之后，要考虑链表化
// 当单个的链表节点个数达到8，并且table的长度达到64，才会树化
// 当单个的链表的节点个数达到8，但是table的长度为达到64，会先进行扩容
static final int MIN_TREEIFY_CAPACITY = 64;             // 最小树化容量64
transient Node<K,V>[] table;                            // 数组
transient int size;                                     // 记录有效映射关系的对数，也是Entry对象的个数
int threshold;                                          // 阈值，当size达到阈值时，考虑扩容
final float loadFactor;                                 // 加载因子，影响扩容的频率
```

### 3. LinkedHashMap

1. LinkedHashMap与HashMap的关系

   LinedHashMap是HashMap的子类。LinkedHashMap是HashMap使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加元素的先后顺序，便于我们遍历所有的key-value

   LinkedHashMap重写了HashMap的如下方法

   ```java
   Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
     LinkedHashMap.Entry<K,V> p = new LinkedHashMap.Entry<K,V>(hash,key,value,e);
     linkNodeLast(p);
     return p;
   }
   ```

2. 底层结构：LinkedHashMap内部定义了一个Entry

   ```java
   static class Entry<K,V> extends HashMap.Node<K,V> {
       Entry<K,V> before, after;	// 增加的一对双向链表
       Entry(int hash, K key, V value, Node<K,V> next) {
           super(hash, key, value, next);
       }
   }
   ```



## 1.5 HashSet和LinkedHashSet

> HashSet底层使用的是HashMap
>
> LinkedHashSet底层使用的是LinkedHashMap



# 第二章 File类与IO流

## 2.1 File类的使用

### 1. 构造器

* <span style="color:orange">`public File(String pathname)`</span>：以pathname为路径创建File对象，可以是绝对路径或者是相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储
* <span style="color:orange">`public File(String parent,String child)`</span>：以parent为父路径，以child为子路径创建File对象
* <span style="color:orange">`public File(File parent,String child)`</span>：根据一个父File对象和自文件路径创建File对象

### 2. 常用方法

​	

```html
<span style="color:red"></span>
<span style="color:orange"></span>
<span style="color:yellow"></span>
```

