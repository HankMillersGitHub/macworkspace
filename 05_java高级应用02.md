# 第一章 数据结构

## 1.1 数据结构的研究对象

### 1. 数据之间的逻辑关系

* <span style="color:orange">集合结构</span>：数据结构中的元素之间除了“同属一个集合”的相互关系外，别无其他关系，集合元素之间没有其他关系
* <span style="color:orange">线性结构</span>：元素之间存在“一对一的”对应关系，比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、队列、栈
* <span style="color:orange">树形结构</span>：元素存在“一对多的”对应关系，比如：家谱、文件系统、组织结构
* <span style="color:orange">图形结构</span>：元素存在“多对多的”对应关系，比如：地铁网

### 2. 数据的存储结构(或物理结构)

1. <span style="color:orange">顺序结构：</span>
   * 顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素
   * 优点：只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问
   * 缺点：必须静态分配连续空间，内存空间的利用率比较低，插入或删除可能需要移动大量元素，效率比较低
2. <span style="color:orange">链式结构：</span>
   * 不需要使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点，节点中除了存放数据本身以外，还需要存放指向下一个节点的指针
   * 优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点，插入或删除元素时，不需要移动大量的元素
   * 缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问
3. <span style="color:orange">索引结构：</span>
   * 除建立存储节点信息外，还建立附加的索引表来记录每个元素节点的地址，索引表由若干索引项组成。索引项的一般形式是：(关键字、地址)
   * 优点：用节点的索引号来确定节点存储地址，检索速度快
   * 缺点：增加了附加的索引表，会占用较多的存储空间，在增加和删除数据时要修改索引表，因而会花费较多的时间
4. <span style="color:orange">散列结构：</span>
   * 根据元素的关键字直接计算出该元素的存储地址，又称为hash存储
   * 优点：检索、增加和删除节点的操作都很快
   * 缺点：不支持排序，一般用线性表存储需要更多的空间，并且记录的关键字不能重复

开发中，更习惯以如下方式理解存储结构：

* 线性表(一对一)：一维数组、单向链表、双向链表、栈结构、队列
* 树(一对多)：二叉树、B+树
* 图(多对多)：
* 哈希表：HashMap、HashSet

### 3. 运算结构

施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能：运算的实现是针对存储结构的，指出运算的具体操作步骤

* 分配资源，建立结构，释放资源
* 插入和删除
* 获取和遍历
* 修改和排序

## 1.2 链表

链表中的基本单位是：节点(Node)

### 1. 单向链表

```java
// 单向链表之基础结构
class Node{
  private Object data;
  private Node next;
  public Node(Object data){
    this.data = data;
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
node1.next = node2;
```

### 2. 双向链表

```java
// 双向链表之基础结构
class Node{
  private Object data;
  private Node prev;
  private Node next;
  public Node(Object data){
    this.data = data;
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
Node node3 = new Node("CC");
node1.prev = null;
node1.next = node2;
node2.prev = node1;
node2.next = node3;
node3.prev = node2;
node3.next = null;
```

### 3. 二叉树

```java
// 二叉树之基本结构
class Node{
  private Object data;
  private Node lLeaf;
  private Node rLeaf;
  public Node(Object data){
    this.data = data;
  }
}
Node root = new Node("root");
Node lLeaf = new Node("lLeaf");
Node rLeaf = new Node("rLeaf");
root.lLeaf = lLeaf;
root.rLeaf = rLeaf;
lLeaf.lLeaf = null;
lLeaf.rLeaf = null;
rLeaf.lLeaf = null;
rLeaf.rLeaf = null;
```

### 4. 栈(Stack)

```java
// 链表实现的栈
class Node{
  Object data;
  Node next;
  public Node(Object data){
    this.data = data;
  }
}
class Stack{
  Node top;
  public Stack(Node top){
    this.top = top;
  }
  // 压栈操作
  public static push(Node node){
    if(top != null){
      top = node;
    }
  }
}
Node node1 = new Node("AA");
Node node2 = new Node("BB");
node1.next = node2;
Stack stack = new Stack(node1);
Stack.push(node2);
```

### 5. 队列(queue)

```java
// 数组实现队列
class Queue{
  Object[] values;
  int size;
  public Queue(int length){
    values = new Object[length];
  }
  // 入队
  public void add(Object ele){
    if(size >= values.length){
      throw new RuntimeException("队列已满，入队失败");
    }
    values[size] = ele;
    size++;
  }
  // 出队
  public Object remove(){
    if(size <= 0){
      throw new RuntimeException("队列已空，出队失败");
    }
    // 取队首元素
    Object obj = values[0];
    // 循环向前
    for(int i = 1;i < size;i++){
      values[i - 1] = values[i];
    }
    // 最后的元素致空
    values[size - 1] = null;
    size--;
    return obj;
  }
}
```

## 1.3 List

### 1. ArrayList

1. 特点：

   > 实现了List接口，存储有序的、可以重复的数据
   >
   > 底层使用Object[]数组存储
   >
   > 线程不安全

2. ArrayList源码解析：

   1. JDK7

      ```java
      // 底层初始化数组，默认长度为十 Object[] elementData = new Object[10];
      ArrayList<String> list = new ArrayList<>();
      // elementData[0] = "AA"
      list.add("AA");
      // elementData[1] = "BB"
      list.add("BB");
      // 。。。
      // 当要添加第十一个元素的时候，底层elementData数组长度扩容，默认扩容为原来长度的1.5倍并将原有数组中的元素赋值到新数组中
      ```
   
   2. JDK8
   
      ```java
      // 底层初始化数组 Object[] elementData = new Object[]{};
      ArrayList<String> list = new ArrayList<>();
      // 首次添加元素时，会初始化数组elementData = new Object[10] elementData[0] = "AA"
      list.add("AA");
      // elementData[1] = "BB"
      list.add("BB");
      // 。。。
      // 当要添加第十一个元素的时候，底层elementData数组长度扩容，默认扩容为原来长度的1.5倍并将原有数组中的元素赋值到新数组中
      ```
      

### 2. LinkedArrayList

1. LinkedList的特点

   > 实现了List接口，存储有序的、可以重复的数据
   >
   > 底层使用双向链表存储
   >
   > 线程不安全的

2. LinkedList在JDK8中的源码解析

   ```java
   LinkedList<String> list = new LinkedList<>();
   // 将AA封装到Node对象中，list对象的属性first(头节点)和last(尾节点)都指向此Node对象
   list.add("AA"); 
   // 将BB封装到Node对象中，两个Node对象构成一个双向链表，头节点还指向Node1，尾节点指向Node2
   list.add("BB");
   // 因为LinkedList使用的是双向链表，不需要考虑扩容问题
   
   /*
   LinkedList内部声明
   class Node<E>{
   	E item;
   	Node<E> next;
   	Node<E> prve;
   }
   */
   ```

### 3. 启示与开发建议

1. ArrayList底层使用数组结构，查找和添加(尾部添加)效率高，时间复杂度为O(1)；对于删除和插入操作效率低，时间复杂度为O(n)
2. LinkedList底层使用双向链表，删除和插入操作效率高，时间复杂度为O(1)，查找和添加效率低，时间复杂度为O(n),(有可能添加操作时间复杂度为O(1));
3. 在选择了ArrayList的前提下有两种创建数组的方式可选
   1. new ArrayList()：底层创建长度为10的数组
   2. new ArrayList(int copicity)：底层创建长度为copicity长度的数组
   3. 如果开发中大体确认数组长度，推荐使用new ArrayList(int copicity)构造器



## 1.4 HashMap

### 1. HashMap中元素的特点

> HashMap中的所有的key彼此之间是不可重复的、无序的，所有的key之间构成一个Set集合
>
> HashMap中的所有的value彼此之间是可重复的、无序的，所有的value构成一个Collection集合
>
> HashMap中的一组key-value，就构成了一个entry
>
> HashMap中的所有的entry彼此之间构成了一个不可重复的、无序的Set集合

### 2. HashMap源码解析

1. JDK7中创建对象和添加数据的过程

   ```java
   // 创建对象的过程中，底层会初始化数组Entry[] table = new Entry[16];
   HashMap<String,Integer> map = new HashMap<>();
   // 将("AA",80)封装为一个Entry对象中，考虑将此对象添加到table对象中
   map.put("AA",80);
   
   // 添加 / 修改 的过程
   /*
   将key1value1添加到当前的map中
   首先，需要调用key1所在的类的hashCode方法，计算key1的哈希值1，此哈希值1经过某种算法(hash(key))后得到哈希值2
   哈希值2在经过某种算法(indexFor())之后确定了Entry在table中的索引位置1
   1.1 如果此索引位置上没有元素，则entry1就添加成功			--> 情况一
   1.2 如果此索引位置上有元素(key2,value2)，则需要继续比较key1和key2的哈希值2 ---> 哈希冲突
    	2.1 如果key1的哈希值2与key2的哈希值2不同，则(key1,value1)也添加成功		--> 情况二
    	2.2 如果key1的哈希值2与key2的哈希值2相同，则需要继续比较key1和key2的equals().要调用key1所在类的equals(key2)方法，将key2作为参数传递进去
    		3.1 调用equals之后返回false：则entry1就添加成功		--> 情况三
    		3.2 调用equals之后返回true：则认为key1和key2相同，默认情况下，value1替换value2.
   
   情况一：将(key1，value1)存放到数组的索引i的位置
   情况二，情况三：(key1，value1)元素与现有的(key2，value2)构成单向链表结构，(key1，value1)指向(key2，value2)
   
   随着不断添加元素，在满足如下条件的情况下，会考虑扩容：
   (size >= threshold) && (null != table[i])
   当元素的个数达到临界值(-> 数组的长度 * 加载因子)时，就考虑扩容。默认的临界值 = 16 * 0.75 --> 12
   默认扩容为原来的二倍
   */
   ```

2. JDK8与JDK7的不同之处

   #### JDK7

   1. 实例化的过程

      ```java
      HashMap<String,Integer> map = new HashMap<>();
      ```

      对应的源码

      ```java
      public HashMap() {
          this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
      }
      public HashMap(int initialCapacity, float loadFactor) {
          //...略...
      
          //通过此循环，得到capacity的最终值，此最终值决定了Entry数组的长度。此时的capacity一定是2的整数倍
          int capacity = 1;
          while (capacity < initialCapacity)
              capacity <<= 1;
      
          this.loadFactor = loadFactor; //确定了加载因子的值
          threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);  //确定了临界值
          table = new Entry[capacity]; //初始化数组，长度为capacity
          
          //..略..
      }
      ```

      其中：

      ```java
      static final int DEFAULT_INITIAL_CAPACITY = 16;
      static final float DEFAULT_LOAD_FACTOR = 0.75f;
      
      final float loadFactor; //加载因子
      int threshold;//临界值
      transient Entry<K,V>[] table; //存储数组的数组
      ```

   2. put(key,value)的过程

      ```java
      public V put(K key, V value) {
          //HashMap允许添加key为null的值。将此(key,value)存放到table索引0的位置。
          if (key == null)
              return putForNullKey(value);
          //将key传入hash()，内部使用了key的哈希值1，此方法执行结束后，返回哈希值2
          int hash = hash(key);
          //确定当前key，value在数组中的存放位置i
          int i = indexFor(hash, table.length);
          
          for (Entry<K,V> e = table[i]; e != null; e = e.next) {
              Object k;
              if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                  V oldValue = e.value;
                  e.value = value;
                  e.recordAccess(this);
                  return oldValue;  //如果put是修改操作，会返回原有旧的value值。
              }
          }
      
          //.....
          addEntry(hash, key, value, i); //将key,value封装为一个Entry对象，并将此对象保存在索引i位置。
          return null; //如果put是添加操作，会返回null.
      }
      ```

      其中：

      ```java
      final int hash(Object k) {
          int h = 0;
          if (useAltHashing) {
              if (k instanceof String) {
                  return sun.misc.Hashing.stringHash32((String) k);
              }
              h = hashSeed;
          }
      
          h ^= k.hashCode();
      
          // This function ensures that hashCodes that differ only by
          // constant multiples at each bit position have a bounded
          // number of collisions (approximately 8 at default load factor).
          h ^= (h >>> 20) ^ (h >>> 12);
          return h ^ (h >>> 7) ^ (h >>> 4);
      }
      
      static int indexFor(int h, int length) {
          return h & (length-1);
      }
      
      void addEntry(int hash, K key, V value, int bucketIndex) {
          //扩容的条件
          if ((size >= threshold) && (null != table[bucketIndex])) {
              resize(2 * table.length); //默认扩容为原有容量的2倍
              hash = (null != key) ? hash(key) : 0;
              bucketIndex = indexFor(hash, table.length);
          }
      
          createEntry(hash, key, value, bucketIndex);
      }
      
      void createEntry(int hash, K key, V value, int bucketIndex) {
          Entry<K,V> e = table[bucketIndex];
          table[bucketIndex] = new Entry<>(hash, key, value, e);
          size++;
      }
      ```

   3. Entry的定义如下：

      ```java
      static class Entry<K,V> implements Map.Entry<K,V> {
          final K key;
          V value;
          Entry<K,V> next;
          int hash;  //使用key得到的哈希值2进行赋值。
      
          /**
               * Creates new entry.
               */
          Entry(int h, K k, V v, Entry<K,V> n) {
              value = v;
              next = n;
              key = k;
              hash = h;
          }
      }
      ```

   #### JDK8

   > 二者不同之处：
   >
   > 1. JDK8中，当我们创建HashMap实例以后，底层并没有初始化table数组，当首次添加(key,value)时，进行判断，如果发现当前table尚未初始化，则对数组进行初始化。
   >
   > 2. JDK8中，HashMap底层定义了Node内部类，替换JDK7中的Entry。意味着我们创建的数组是Node[]
   >
   > 3. JDk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中，如果此时角标i位置上有元素，JDK7中是将新的(key,value)元素指向已有的旧的元素(头插法)，JDK8中是将旧的元素指向新的(key,value)元素(尾插法)。(七上八下)
   >
   > 4. JDK7：数组+链表。JDK8：数组+单向链表+红黑树。
   >
   >    <span style="color:orange">什么时候会使用红黑树？</span>如果数组索引i位置上的元素个数达到8，并且数组的长度达到64，我们就将此索引位置i上的多个元素，改为使用红黑树的结构进行存储。(红黑树进行put/get/remove操作时的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)要好，性能更高)。
   >
   >    <span style="color:orange">什么时候会将红黑树变为单向链表？</span>当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树的结构退化为单向链表，

3. 属性 / 字段

```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;     // 默认初始容量16
static final int MAXIMUM_CAPACITY = 1 << 30;            // 最大容量 1 << 30
static final float DEFAULT_LOAD_FACTOR = 0.75f;         // 默认加载因子
static final int TREEIFY_THRESHOLD = 8;                 // 默认树化阈值8，当链表长度达到这个长度之后，就要考虑树化
static final int UNTREEIFY_THRESHOLD = 6;               // 默认反树化阈值6，当树中的某个节点达到此阈值之后，要考虑链表化
// 当单个的链表节点个数达到8，并且table的长度达到64，才会树化
// 当单个的链表的节点个数达到8，但是table的长度为达到64，会先进行扩容
static final int MIN_TREEIFY_CAPACITY = 64;             // 最小树化容量64
transient Node<K,V>[] table;                            // 数组
transient int size;                                     // 记录有效映射关系的对数，也是Entry对象的个数
int threshold;                                          // 阈值，当size达到阈值时，考虑扩容
final float loadFactor;                                 // 加载因子，影响扩容的频率
```

### 3. LinkedHashMap

1. LinkedHashMap与HashMap的关系

   LinedHashMap是HashMap的子类。LinkedHashMap是HashMap使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加元素的先后顺序，便于我们遍历所有的key-value

   LinkedHashMap重写了HashMap的如下方法

   ```java
   Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
     LinkedHashMap.Entry<K,V> p = new LinkedHashMap.Entry<K,V>(hash,key,value,e);
     linkNodeLast(p);
     return p;
   }
   ```

2. 底层结构：LinkedHashMap内部定义了一个Entry

   ```java
   static class Entry<K,V> extends HashMap.Node<K,V> {
       Entry<K,V> before, after;	// 增加的一对双向链表
       Entry(int hash, K key, V value, Node<K,V> next) {
           super(hash, key, value, next);
       }
   }
   ```



## 1.5 HashSet和LinkedHashSet

> HashSet底层使用的是HashMap
>
> LinkedHashSet底层使用的是LinkedHashMap



# 第二章 File类与IO流

## 2.1 File类的使用

### 1. 构造器

* <span style="color:orange">`public File(String pathname)`</span>：以pathname为路径创建File对象，可以是绝对路径或者是相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储
* <span style="color:orange">`public File(String parent,String child)`</span>：以parent为父路径，以child为子路径创建File对象
* <span style="color:orange">`public File(File parent,String child)`</span>：根据一个父File对象和自文件路径创建File对象

### 2. 常用方法

#### 1. 获取文件和目录基本信息

* public String getName()获取名称
* public String getPath()获取路径
* public String getAbsolutePath()获取绝对路径
* public File getAbsoluteFile()获取绝对路径表示的文件
* public String getParent()获取上层文件目录路径，若无返回null
* public long length()获取文件长度(字节数)，不能获取目录的长度
* public long lastModified()获取最后一次修改时间，毫秒值

#### 2. 列出目录的下一级

* public String[] list()返回一个String数组，表示该File目录中所有的子文件或目录
* public File[] listFiles()返回一个File数组，表示该File目录中所有的子文件或目录

#### 3. File类的重命名功能

* public boolean renameTo(File dest)：把文件重命名为指定的文件路径

  ```java
  /*
  * public boolean renameTo(File dest)：把文件重命名为指定的文件路径
  * File file = new File("/Volumes/TOSHIBA EXT/JavaWorkSpace/JavaAdevancedApplications/_07_IO/hello.txt");
    File file1 = new File("/Volumes/TOSHIBA EXT/JavaWorkSpace/JavaAdevancedApplications/_07_IO/IO/test/world.txt");
  * 要想此方法返回true，要求
  *   file必须存在，且file1必须不存在，且file1所在的文件目录需要存在
  * */
  ```

#### 4. 判断功能的方法

* public boolean exists()此file表示的文件或目录是否实际存在
* public boolean isDirectory()此file表示的是否是目录
* public boolean isFile()此file表示的是否为文件
* public boolean canRead()判断是否可读
* public boolean canWrite()判断是否可写
* public boolean isHidden()判断是否隐藏

#### 5. 创建、删除功能

* public boolean createNewFile()创建文件，如果文件存在，则不创建并返回false

* public boolean mkdir()创建文件目录，如果此文件目录存在，就不创建了，如果此文件目录的上层不存在，也不创建

* public boolean mkdirs()创建文件目录，如果上层不存在，一并创建

* public boolean delete()删除文件或者文件夹

  删除注意事项：java中删除不会进入回收站，要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录

## 2.2 IO流

### 1. IO流的分类

1. 按照数据的流向不同分为：输入输出流
   * 输入流：把数据从其他设备上读取到内存中的流，以InputStream、Reader结尾
   * 输出流：把数据从内存中写出道其他设备上的流，以OutputStream、Writer结尾
2. 按照操作的数据单位的不同分为：字节流(8bit)和字符流(16bit)
   * 字节流：以字节为单位，读写数据的流，以InputStream、OutputStream结尾
   * 字符流：以字符为单位，读写数据的流，以Reader、Writer结尾
3. 按照IO流的角色不同分为：节点流和处理流
   * 节点流：直接从数据源或目的地读写数据
   * 处理流：不直接连接到数据源或目的地，而是链接在已经存在的流(节点流或处理流)上，通过对数据的处理为程序提供更强大的读写能力

### 2. 流的API

* java中的IO流共涉及40多个类，实际上非常规则，都是从如下四个抽象基类派生的

  | 抽象基类 | 输入流      | 输出流        |
  | -------- | ----------- | ------------- |
  | 字节流   | InputStream | OutputSteream |
  | 字符流   | Reader      | Writer        |

* 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀

  | 分类       | 字节输入流           | 字节输出流             | 字符输入流        | 字符输出流        |
  | ---------- | -------------------- | ---------------------- | ----------------- | ----------------- |
  | 抽象基类   | InputStream          | OutputSteream          | Reader            | Writer            |
  | 访问文件   | FileInputStream      | FileOutputSteream      | FileReader        | FileWriter        |
  | 访问数组   | ByteArrayInputStream | ByteArrayOutputSteream | CharArrayReader   | CharArrayWriter   |
  | 访问管道   | PipedInputStream     | PipedOutputSteream     | PipedReader       | PipedWriter       |
  | 访问字符串 |                      |                        | StringReader      | StringWriter      |
  | 缓冲流     | BufferedInputStream  | BufferedOutputSteream  | BufferedReader    | BufferedWriter    |
  | 转换流     |                      |                        | InputStreamReader | InputStreamWriter |
  | 对象流     | ObjectInputStream    | ObjectOutputSteream    |                   |                   |
  |            | FilterInputStream    | FilterOutputSteream    | FilterReader      | FilterWriter      |
  | 打印流     |                      | PrintSteream           |                   | PrintWriter       |
  | 推回输入流 | PushbackInputStream  |                        | PushbackReader    |                   |
  | 特殊流     | DataInputStream      | DataOutputSteream      |                   |                   |

<span style="color:red">常用的节点流：</span>

* 文件流：FileInputStream、FileOutputSteream、FileReader、FileReader
* 字节/字符数组流：ByteArrayInputStream、ByteArrayOutputSteream、CharArrayReader、CharArrayWriter

### 3. FileReader和FileWriter的使用

1. 执行步骤

   1. 创建读取或写出文件的File类的对象

   2. 创建输入流或输出流

   3. 具体的读入或写出的过程

      读入：read(char[] cbuffer)

      写出：write(String str) / write(char[] cbuffer,0,len)

   4. 关闭流资源

2. 注意点：

   1. 因为涉及到流资源的关闭操作，所以如果出现异常的话，需要使用try-catch-fianlly的方式对异常进行处理

   2. 对于输入流来讲，要求file类的对象对应的物理磁盘上的文件必须存在，否则会报FileNotFoundException

   3. 对于输出流来讲，File类的对象对应的物理磁盘上的文件可以不存在，

      1. 如果不存在，会自动创建文件，并写入数据
      2. 如果存在，使用FileWriter(File filre) 或 FileWriter(File file,false):输出数据过程中，会进行文件覆盖
      3. 如果存在，使用FileWriter(File file , true)，会在原文件内容的后面进行追加内容

<span style="color:red">注意！字符流不适合用来处理非文本文件，要使用字节流来进行处理</span>

### 4. FileInputStream和FileOutputStream

1. 执行步骤

   1. 创建读取或写出文件的File类的对象

   2. 创建输入流或输出流

   3. 具体的读入或写出的过程

      读入：read(byte[] cbuffer)

      写出：write(String str) / write(byte[] cbuffer,0,len)

   4. 关闭流资源

2. 注意点：

   1. 因为涉及到流资源的关闭操作，所以如果出现异常的话，需要使用try-catch-fianlly的方式对异常进行处理

   2. 对于输入流来讲，要求file类的对象对应的物理磁盘上的文件必须存在，否则会报FileNotFoundException

   3. 对于输出流来讲，File类的对象对应的物理磁盘上的文件可以不存在，

      1. 如果不存在，会自动创建文件，并写入数据

      2. 如果存在，使用FileOutputStream(File filre) 或 FileOutputStream(File file,false):输出数据过程中，会进行文件覆盖

         对于字符流：只能用来操作文本文件，不能用来处理非文本文件

         对于字节流：通常用来处理非文本文件，但是，如果涉及到文本文件的复制操作，也可以使用字节流

      3. 如果存在，使用FileOutputStream(File file , true)，会在原文件内容的后面进行追加内容

​      

### 5. 缓冲流buffered

1. 基础IO流的框架

   | 抽象基类     | 四个节点流       | 四个缓冲流           |
   | ------------ | ---------------- | -------------------- |
   | InputStream  | FileInputStream  | BufferedInputStream  |
   | OutputStream | FileOutputStream | BufferedOutputStream |
   | Reader       | FileReader       | BufferedReader       |
   | Writer       | FileWriter       | BufferedWriter       |

2. 缓冲流的作用

   提升文件读写的效率。

3. 使用方法

   > 四个缓冲流使用的方法	使用的方法
   >
   > 处理非文本文件的字节流
   >
   > BufferedInputStream	   read(byte[] buffer)
   >
   > BufferedOutputStream	write(byte[] buffer,0,len)
   >
   > 处理文本文件的字符流
   >
   > BufferedReader		     read(char[] cbuffer) \ readLine()
   >
   > BufferedWriter		      write(char[] cbuffer,0,len)

4. 使用步骤

   1. 创建File的对象，流的对象(包括文件流、处理流)

   2. 使用缓冲流实现：读取数据 或 写出数据的过程

      1. 读取：int read(char[] cbuffer / byte[] buffer)： 每次将数据读入到cbuffer或buffer数组中，并返回读入到数组中的数据

      2. 写出：void write(String str / char[] cbuffer)：将str或cbuffer写出到文件中

         ​	   void write(byte[] buffer)：将buffer写出到文件中

   3. 关闭资源

### 6. 转换流

1. 复习

   字符编码：(能看得懂的) 字符、字符串、字符数组-->字节、字节数组 (看不懂的)

   字节编码：字节、字节数组 (看不懂的)-->(能看得懂的) 字符、字符串、字符数组

2. 如果希望程序在读取文本文件时，不出现乱码，需要注意什么

   解码时使用的字符集必须与编码时使用的字符集相同，或者兼容才可以不出现乱码

3. 转换流

   1. 作用:字节 --> InputStreamReader --> 字符 / 字符 --> OutputStreamWriter --> 字节

   2. API：

      InputStreamReader()：将一个输入型的字节流转换为输入型的字符流

      OutputStreamWriter()：将一个输出型的字符流转换为输出型的字节流

4. 关于字符集的理解：

   1. 在存储的<span style="color:red">文件</span>中的字符：
      1. ASCII：主要用来存储abcd等英文字符和123以及常用标点符号等。每个字符占一个字节
      2. iso-8859-1：使用单字节进行，兼容ascii码
      3. GBK：用来存储包括中文简体、繁体、abcd等英文字符和123、常用的标点符号等字符，其中中文字符使用双字节进行存储，向下兼容ascii码，意味着英文字符，123和标点符号还是使用单字节编码
      4. UTF-8：可以用来存储世界范围内主要语言的所有字符，使用1-4个不等的字节表示一个字符，中文字符使用三个字节进行存储，同样兼容ascii码，意味着英文字符，123和标点符号还是使用单字节编码
   2. 在<span style="color:red">内存</span>中的字符
      1. 一个字符(char)占用两个字节， 在内存中使用的字符集称为unicode字符集



### 7. 对象流

1. 数据流及其作用：

   DataOutputStream:可以将内存中的基本数据类型的变量，String类型的变量写出到具体的文件中

   DataInputStream:将文件中保存的数据还原为内存中的基本数据类型的变量、String类型的变量

2. 对象流及其作用：

   1. API：

      1. ObjectInputStream
      2. ObjectOutputStream

   2. 作用：

      可以读写基本数据类型的变量、引用数据类型的变量

3. 对象的序列化机制：

   对象序列化机制允许把内存中的java对象转换成平台无关的二进制流，从而允许把这种二进制流持久的保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的java对象

4. 如下两个过程使用的流：

   1. 序列化过程：使用ObjectOutputStream流实现，将内存中的java对象保存在文件中或通过网络传输出去
   2. 反序列化过程：使用ObjectInputStream流实现，将文件中的数据或网络传输过来的数据还原为内存中的java对象

5. 自定义类要想实现序列化机制，需要满足：

   1. 自定义类需要实现Serialzable接口

   2. 要求自定义类声明一个全局常量`static final long serialVersionUID = 42L;`用来唯一标识当前的类

   3. 要求自定义类的各个属性也必须是可序列化的

      > 对于基本数据类型的属性，默认就是可序列化的
      >
      > 对于引用数据类型：要求实现Serialzable接口

6. 注意点：

   1. 如果不声明全局常量serialVersionUID，系统会自动生成一个serialVersionUID，如果修改此类，会导致serialVersionUID变化，进而导致反序列化时，出现<span style="color:red">InvalidClassException</span>异常
   2. 类中的属性如果声明为transient或static，则不会进行序列化 

# 第三章 网络编程

## 1. 网络编程概述

### 1.1 软件架构

* C/S架构：全称为Client/Server结构，是指客户端和服务器结构，常见的有QQ、美团、360等软件
* B/S架构：全称为Browser/Server结构，是指浏览器和服务器结构，常见的有googleChrome、IE、Safari等

### 1.2 网络基础

* 计算机网络：

  把分布在不同的地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能强的网络系统，从而使众多的计算机可以方便的互相传递信息、共享硬件、软件、数据信息等资源

* 网络编程的目的：直接或间接的通过网络协议与其他计算机实现数据交换、进行通讯

* 网络编程中的三个主要问题

  1. 如何准确的定位网络上的一台或多台主机
  2. 如何定位主机上的特定应用
  3. 找到主机后，如何可靠并高效的进行数据传输

## 2. 网络通信要素

1. 使用IP地址(定位网络上的一台或多台主机)
2. 使用端口号(定位主机上的特定应用)
3. 规范网络通信协议(可靠并高效的进行数据传输)

## 3. 通信要素一：IP地址

### 3.1 作用

IP地址用来给网络中的一台计算机设备做唯一编号的

### 3.2 IP地址分类

1. IP地址分类方式一：
   1. IPV4：是一个32位的二进制数，通常被分为四个字节，表示成a.b.c.d的形式，以点分十进制表示，例如：`192.168.0.1`，其中a、b、c、d都是0-255之间的十进制整数
   1. IPV6：占用十六个字节
1. IP地址分类方式二：
   1. 公网地址
   2. 私有地址：192.168开头的就是私有地址，范围是192.168.0.0 - 192.168.255.255
   

### 3.3 本地回路地址

127.0.0.1

### 3.4 域名

域名可以便捷的记录ip地址

www.baidu.com www.bilibili.com 

## 4. 通信要素二：端口号

> 可以唯一标识主机中的进程
> 不同的进程分配不同的端口号
> 范围：0-65535

## 5. 通信要素三：网络通信协议

TCP/IP协议
| OSI参考模型 | 各层作用                     | TCP/IP参考模型  | TCP/IP参考模型各层对应协议 | 对应结构               |
| ----------- | ---------------------------- | --------------- | -------------------------- | ---------------------- |
| 应用层      | 为应用程序提供服务           | 应用层          | HTTP / FTP / Telnet / DNS  | 应用程序               |
| 表示层      | 数据格式转换、数据加密       | 应用层          | HTTP / FTP / Telnet / DNS  | 应用程序               |
| 会话层      | 建立、管理和维护会话         | 应用层          | HTTP / FTP / Telnet / DNS  | 应用程序               |
| 传输层      | 建立、管理和维护端对端的连接 | 传输层          | TCP / UDP                  | 操作系统               |
| 网络层      | IP选址及路由选择             | 网络层          | IP / ICMP / ARP            | 操作系统               |
| 数据链路层  | 提供介质访问和链路管理       | 物理+数据链路层 | Link                       | 设备驱动程序、网络接口 |
| 物理层      | 物理传输                     | 物理+数据链路层 | Link                       | 设备驱动程序、网络接口 |

<span style="color:orange">目的是为了实现可靠而高效的数据传输，OSI模型过于理想化没有实施，实际采用的是TCP/IP协议，分为应用层、传输层、网络层、数据链路层</span>

## 6. 网络编程API

### 6.1 InetAddress类

1. 作用：该类的实例就代表一个IP地址

2. 实例化的方式

   ```java
   // InetAddress.getByName获取制定ip对应的ia实例
   InetAddress ia1 = InetAddress.getByName("192.168.0.1");
   // InetAddress.getLocalHost获取本地IP对应的InetAddress的实例
   InetAddress ia3 = InetAddress.getByName("www.baidu.com");
   ```

3. 常用方法

   ```java
   // 获取当前IP地址的域名
   System.out.println(inetAddress.getHostName());
   // 获取当前实例的IP地址
   System.out.println(inetAddress.getHostAddress());
   ```

### 6.2 Socket类

* 网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字(Socket)
* 利用套接字(Socket)开发网络应用程序早已被广泛使用，以至于成为事实上的标准，网络通信实际上就是Socket间的通信
* 通信的两端都要有Socket，是两台机器间通信的端点
* Socket允许程序把网络连接当成一个流，数据在两个Socket之间通过IO进行传输
* 一般主动发起通信的程序属于客户端，等待通信的程序是服务端
* Socket分类
  * 流套接字(Stream Socket)：使用TCP提供可以来的字节流服务
    * ServerSocket：此类实现TCP服务套接字，服务器套接字等待请求通过网络传入
    * Socket：此类实现客户端套接字，套接字是两台机器间通信的端点
  * 数据报套接字(Datagram Socket)：使用UDP提供尽力而为的数据报服务
    * DatagramSocket：此类用来发送和接收UDP数据报包的套接字

## 7. URL编程

1. URL(Uniform Resource Locator)：统一资源定位符(种子)

2. 作用：

   一个具体的url就对应着互联晚上某一资源的地址

3. url格式：Http://localhost:8080/floder/file.test?name=Hank

   Http  ：应用层协议
   localhost：ip地址
   8080:端口号
   。。。。：资源地址
   后续：参数列表
4. URL类的实例化及常用方法

   | 方法名      | 返回值 | 作用                |
   | ----------- | ------ | ------------------- |
   | getProtocol | String | 获取该URL的协议名   |
   | getHost     | String | 获取该URL的主机号   |
   | getPort     | String | 获取该URL的端口号   |
   | getPath     | String | 获取该URL的文件路径 |
   | getFile     | String | 获取该URL的文件名   |
   | getQuery    | String | 获取该URL的查询名   |
5. 下载指定的URL资源到本地

   ```java
   package URL;
   
   import org.junit.Test;
   
   import java.io.File;
   import java.io.FileOutputStream;
   import java.io.IOException;
   import java.io.InputStream;
   import java.net.HttpURLConnection;
   import java.net.MalformedURLException;
   import java.net.URL;
   import java.net.URLConnection;
   
   /**
    * @Description:
    * @auther mazhonghao
    * @date 2024/5/25 08:08
    */
   public class URLTest {
       public static void main(String[] args) {
           String str = "http://localhost:8080/examples/demo.jpg?name=Hank&age=19";
           try {
               URL url = new URL(str);
               System.out.println(url.getProtocol());
               System.out.println(url.getHost());
               System.out.println(url.getPort());
               System.out.println(url.getPath());
               System.out.println(url.getFile());
               System.out.println(url.getQuery());
           } catch (MalformedURLException e) {
               throw new RuntimeException(e);
           }
       }
       @Test
       public void test1() throws RuntimeException {
           // 1. 获取url实例
           String str = "http://localhost:8080/examples/demo.jpg?name=Hank&age=19";
           try {
               URL url = new URL(str);
               // 2. 建立与服务器的连接
               HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
               // 3. 创建输入流输出流
               InputStream is = urlConnection.getInputStream();
               File file = new File("demo.jpg");
               FileOutputStream fos = new FileOutputStream(file);
               // 4. 读写资源
               byte[] buffer = new byte[1024];
               int len;
               while ((len = is.read(buffer)) != -1){
                   fos.write(buffer,0,len);
               }
               // 5. 关闭流
               fos.close();
               is.close();
               urlConnection.disconnect();
           } catch (IOException e) {
               throw new RuntimeException(e);
           }
       }
   }
   ```

# 第四章 反射机制

## 1. 举例及问题

1. 面向对象中创建对象，调用指定结构(属性、方法)等功能，可以不使用反射，也可以使用反射，有什么区别

   > 不使用反射，需要考虑封装性，出了类之后就不能调用私有结构
   >
   > 使用反射，可以打破封装性，可以调用运行时类中的任意属性和方法，包括私有的属性和方法

2. 以前创建对象并调用方法的方式，与现在使用反射创建对象并调用方法的对比，使用频率及场景

   > 从开发者的角度讲，开发中主要完成业务代码，对于相关的对象，方法的调用都是确定的，所以我们用非反射的形式多一点
   >
   > 因为反射体现了动态性(可以在运行时动态的获取对象所属的类，动态的调用相关的方法)，所以在设计框架的时候会大量使用反射
   >
   > 框架 = 注解 + 反射 + 设计模式

3. 单例模式中的饿汉和懒汉，私有化类构造器，通过反射，可以创建单例模式中的类的多个对象嘛

   > 可以

4. 通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突，是不是java设计存在的bug

   > 不存在bug
   >
   > 封装性：体现的是是否建议我们调用内部API的问题，比如在private声明的结构是不建议调用的
   >
   > 反射体现的是我们能否调用的问题，因为类的完整结构都加载到了内存中，我们就有能力调用

## 2. 反射

<span style="color:orange">Java反射提供的功能</span>：

* 在运行时判断任意一个对象所属的类
* 在运行时构造任意一个类的对象
* 在运行时判断任意一个类所具有的成员变量和方法
* 在运行时获取范型信息
* 在运行时低哦啊用任意一个对象的成员变量和方法
* 在运行时处理注解
* 生成动态代理

<span style="color:orange">反射相关的API</span>

`java.lang.Class`：代表一个类

`java.lang.reflect.Method`：代表类的方法

`java.lang.reflect.Field`：代表类的成员变量

`java.lang.reflect.Constructor`：代表类的构造器

<span style="color:orange">反射的优缺点：</span>

优点：

* 提高了java程序的灵活性和扩展性，降低了耦合度，提高自适应能力
* 允许程序创建和控制任何类的对象，无需提前硬编码目标类

缺点：

* 反射的性能较低，反射机制主要用在对灵活性和扩展性要求很高的系统框架上
* 反射会模糊程序内部逻辑，逻辑较差

## 3. Class类

1. Class类的理解

   针对于编写好的.java源文件进行编译(使用javac.exe)，会生成一个或多个.class字节码文件，接着，我们使用java.exe命令对指定的.class文件进行解释运行。这个过程当中，我们需要将.class字节码文件加载(类的加载器)到内存中(存放在方法区)，加载到内存中的.class文件对应的结构即为Class的一个实例。

   `Class clazz1 = Person.class;`

   `Class clazz2 = String.class;`

   说明：运行时类在内存中会缓存起来，在整个执行期间，只会加载一次。

2. 体会：Class看作是反射的源头

   

3. 获取Class实例的几种方式(掌握前三种)

   ```java
   // 1. 调用运行时类的静态属性
   Class<User> clazz1 = com._02_Class.User.class;
   // 2. 调用运行时类的对象的getClass()
   com._02_Class.User user = new com._02_Class.User();
   Class clazz2 = user.getClass();
   // 3. 调用Class的静态方法forName(String className)
   Class<?> clazz3 = Class.forName("com._02_Class.User");// 全类名
   // 4. 使用类的加载器的方式(了解)
   Class<?> clazz4 = ClassLoader.getSystemClassLoader().loadClass("com._02_Class.User");
   System.out.println(clazz1 == clazz4); // true
   ```

4. Class的实例都可以指向那些结构？

   1. class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类
   2. interface：接口
   3. []：数组
   4. enum：枚举类
   5. annotation：注解@interface
   6. primitive type：基本数据类型
   7. void：

5. 类的加载过程

   过程一：类的装载(Loading)

   将类的class文件读入内存，并为之创建一个Java.lang.Class对象，此过程由类的加载器完成

   过程二：类的链接(Linking)

   验证(verify)：确保加载的类的信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题

   准备(prepare)：正式为类变量(static)分配内存并设置类变量默认初始化值的阶段，这些内存都将在方法区中进行分配

   解析(resolve)：虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程

   过程三：初始化(initialization)

   执行类构造器`<clinit>()`方法的过程

   类构造器`<clinit>()`方法是有编译期自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的

6. 类的加载器(JDK8版本为例)

   1. 作用：负责类的加载，并对应一个Class的实例

   2. 分类(分为两种)

      1. BootStrapClassLoader：引导类加载器，启动类加载器

         使用c/c++编写，不能通过java代码获取其实例

         负责加载java的核心库(JAVA_HOME/jre?lib/tr.jar或sun.boot.class.path路径下的内容)

      2. 继承于ClassLoader的类加载器

         1. ExtensionClassLoader;扩展类加载器

            负责加载从java.ext.dirs系统属性所制定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录下加载类库

         2. SystemClassLoader/ApplicationClassLoader:系统类加载器、应用程序类加载器

            我们自定义的类默认使用的类的加载器

         3. 用户自定义加载器

            实现应用隔离(同一个类在一个应用程序中可以加载多份)；数据加密

   3. 以上的类的加载器是否存在继承关系

      没有继承关系；

      ```java
      class ClassLoader{
        ClassLoader parent;
        public ClassLoader(ClassLoader parent){
          this.parent = parent;
        }
      }
      // 测试代码
      ClassLoader loader1 = new ClassLoader();
      ClassLoader loader2 = new ClassLoader(loader1);
      // 我们就把loader0叫做loader1的父类加载器
      ```

7. 使用类的加载器获取流，并读取配置文件信息

   ```java
   @Test
   public void test3() throws IOException {
       Properties pros = new Properties();
       // 通过类加载器获取的文件的路径在当前module下的src下
       InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("info.properties");
       pros.load(is);
       String name = pros.getProperty("name");
       String password = pros.getProperty("password");
       System.out.println(name + ":" + password);
   }
   @Test
   public void test4() throws IOException {
       // 通过properties获取配置文件
       Properties pros = new Properties();
       // 文件的路径在当前module下
       FileInputStream fis = new FileInputStream(new File("info.properties"));
       pros.load(fis);
       String name = pros.getProperty("name");
       String password = pros.getProperty("password");
       System.out.println(name + ":" + password);
   }
   ```

## 4. 反射的应用

### 1. 创建运行时类的对象

1. 如何实现？

   通过Class实例调用newInstance()即可

2. 要想创建对象，需要满足：

   1. 要求运行类中必须提供一个空参构造器
   2. 要求提供的空参的构造器必须可用

3. javabean中要求给当前类提供一个公共的空参构造器，有什么用

   1. 子类对象在实例化时，子类的构造器首行默认调用父类空参的构造器
   2. 在反射中，经常用来创建运行时类的对象，那么我们要求，各个运行时类都要提供空参构造器便于编写通用的创建运行时类对象的代码

4. jdk9中被标识为过时，替换成什么结构

   通过Constructor类调用newInstance(..,.)

### 2. 获取运行时类的内部结构

1. 获取运行时类的内部结构1:所有的属性、方法、构造器

   ```java
   package com._03_reflectapply.apply2;
   
   import com._03_reflectapply.data.Person;
   import org.junit.Test;
   
   import java.lang.annotation.Annotation;
   import java.lang.reflect.Method;
   import java.lang.reflect.Modifier;
   
   /**
    * @Description:
    * @auther mazhonghao
    * @date 2024/5/27 10:35
    */
   public class MethodsTest {
       @Test
       public void test1(){
           Class<Person> clazz = Person.class;
           // getMethods() 获取到运行时类本身及其所有的父类中声明为public权限的方法
           Method[] methods = clazz.getMethods();
           for (Method m : methods){
               System.out.println(m);
           }
           System.out.println("-------------");
           // getDeclaredMethods() 获取当前运行时类中声明的所有的方法
           Method[] declaredMethods = clazz.getDeclaredMethods();
           for (Method m : declaredMethods){
               System.out.println(m);
           }
       }
       // 注解信息
       // 权限修饰符 返回值类型 方法名(形参类型1 参数1，形参类型2 参数2 ，.....) throws 异常类型1，异常类型2......{}
       @Test
       public void test2(){
           Class<Person> clazz = Person.class;
           Method[] declaredMethods = clazz.getDeclaredMethods();
           for (Method m : declaredMethods){
               // 1. 获取方法声明的注解
               Annotation[] annos = m.getAnnotations();
               for (Annotation a : annos){
                   System.out.println(a);
               }
               // 2. 权限修饰符
               System.out.print(Modifier.toString(m.getModifiers()) + "\t");
               // 3. 返回值类型
               System.out.print(m.getReturnType().getName() + "\t");
               // 4. 方法名
               System.out.print(m.getName());
               System.out.println("(");
               // 5. 形参列表
               Class<?>[] parameterTypes = m.getParameterTypes();
               if(!(parameterTypes == null && parameterTypes.length == 0)){
                   for (int i = 0;i < parameterTypes.length; i++){
                       if(i == parameterTypes.length - 1){
                           System.out.println(parameterTypes[i].getName() + "args_" + i);
                           break;
                       }
                       System.out.println(parameterTypes[i].getName() + "args_" + i + ",");
                   }
               }
               System.out.println(")");
               // 6. 抛出异常
               Class<?>[] exceptionTypes = m.getExceptionTypes();
               if(exceptionTypes.length > 0){
                   System.out.print("throws ");
                   for (int i = 0; i < exceptionTypes.length; i++) {
                       if(i == exceptionTypes.length - 1){
                           System.out.print(exceptionTypes[i].getName());
                           break;
                       }
                       System.out.print(exceptionTypes[i].getName() + ",");
                   }
               }
               System.out.println();
           }
       }
   }
   
   ```

   

2. 获取运行时类的内部结构2:父类、接口、包、带范型的父类、父类的范型等

   ```java
   package com._03_reflectapply.apply2;
   
   import com._03_reflectapply.data.Person;
   import com.sun.corba.se.spi.orbutil.threadpool.NoSuchThreadPoolException;
   import org.junit.Test;
   
   import java.lang.reflect.ParameterizedType;
   import java.lang.reflect.Type;
   
   /**
    * @Description:
    * @auther mazhonghao
    * @date 2024/5/28 08:57
    */
   public class OtherTest {
       // 获取运行时类的内部结构：父类、接口们、包、带范型的父类、父类的范型等
       // 1. 获取运行时类的父类
       @Test
       public void test1() throws ClassNotFoundException {
           Class<?> clazz = Class.forName("com._03_reflectapply.data.Person");
           System.out.println(clazz.getSuperclass());
       }
       // 2. 获取运行时类实现的接口
       @Test
       public void test2() throws ClassNotFoundException {
           Class<?> clazz = Class.forName("com._03_reflectapply.data.Person");
           Class<?>[] interfaces = clazz.getInterfaces();
           for(Class c : interfaces){
               System.out.println(c);
           }
   
       }
       // 3. 获取运行时类所在的包
       @Test
       public void test3() throws ClassNotFoundException {
           Class<?> clazz = Class.forName("com._03_reflectapply.data.Person");
           System.out.println(clazz.getPackage());
       }
       // 4. 获取运行时类带范型的父类
       @Test
       public void test4() throws ClassNotFoundException {
           Class clazz = Class.forName("com._03_reflectapply.data.Person");
           System.out.println(clazz.getGenericSuperclass());
       }
       // 5. 获取运行时类父类的范型
       /**
        * 平时写的代码：
        *      类型一：业务逻辑代码 (多关注)
        *      类型二：算法逻辑代码 (多积累)
        * */
       @Test
       public void test5() throws ClassNotFoundException {
           Class<?> clazz = Class.forName("com._03_reflectapply.data.Person");
           // 获取带范型的父类 Type是一个接口Class实现了此接口
           Type superClass = clazz.getGenericSuperclass();
           // 如果父类是带范型的，则可以强转伟ParamterizedType
           ParameterizedType paramType = (ParameterizedType) superClass;
           // 调用getActualTypeArguments()获取范型的参数，结果是一个数组，因为可能有多个范型参数
           Type[] actualTypeArguments = paramType.getActualTypeArguments();
           for (Type actual : actualTypeArguments){
               // 获取范型参数的名称
               System.out.println(((Class)actual).getName());
           }
       }
   
   }
   ```

### 3. 调用制定的结构：属性、方法、构造器

1. 调用指定的属性(步骤)

   ```java
   Class<Person> clazz = Person.class;
   Person person = clazz.newInstance();
   // 1. 通过Class调用getDeclaredField(String fieldName)获取运行时类中指定名的属性
   Field nameField = clazz.getDeclaredField("name");
   // 2. setAccessible(true) 确保此属性可以访问
   nameField.setAccessible(true); // 将访问是否非法设置为合法
   // 2. 通过field的实例调用set() get()方法，获取并设置age的值
   nameField.set(person,"Hank");
   System.out.println(nameField.get(person));
   ```

2. 调用指定的方法(步骤)

   ```java
   Class<Person> clazz = Person.class;
   Person person = clazz.newInstance();
   // 1. 通过Class的实例调用getDeclaredMethod()获取当前运行时类的方法
   Method showNation = clazz.getDeclaredMethod("showNation",String.class,int.class);
   // 2. 保证有调用方法的权限
   showNation.setAccessible(true);
   // 3. 通过method实例调用invoke(实例，参数)方法，即为对method对应的方法的调用
   // invoke的返回值即为method的返回值
   // 特别的：如果method对应的方法的返回值类型为void，则invoke返回值为null
   Object returnValue = showNation.invoke(person, "Chinese", 10);
   System.out.println(returnValue);
   ```

3. 调用指定的构造器

   ```java
   Class<Person> clazz = Person.class;
   // 1. 通过Class实例调用getDeclaredConstructor(Class...args)获取指定类型参数类型的构造器
   Constructor<Person> constructor = clazz.getDeclaredConstructor(String.class, int.class);
   // 2. 确保此构造器是可以访问的
   constructor.setAccessible(true);
   // 3. 通过constructor实例调用newInstance(Object...objs)返回一个运行时类的实例
   Person person = constructor.newInstance("Hank", 19);
   System.out.println(person);
   ```

# 第五章 JDK8-17新特性

## 1. Lambda表达式

1. Lambda表达式的使用举例

   (01,02) -> Integer.compare(01,02);

2. Lambda表达式的格式举例

   -> : lambda操作符或箭头操作符

   -> 左边：lambda的形参列表，对应着要重写的接口中的抽象方法的形参列表 

   -> 右边：

```html
<span style="color:red"></span>
<span style="color:orange"></span>
<span style="color:yellow"></span>
```

